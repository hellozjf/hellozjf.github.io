# 第七章 高级主题

## 7.1. 自定义客户端连接

在某些情况下，可能需要定制HTTP消息通过线路传输的方式超出使用HTTP参数的可能性，以便能够处理非标准的，不合规的行为。 例如，对于网络爬虫，可能需要强制HttpClient接受格式错误的响应头，以便挽救消息的内容。

通常，插入自定义消息解析器或自定义连接实现的过程涉及以下几个步骤：

* 提供自定义LineParser / LineFormatter接口实现。 根据需要实现消息解析/格式化逻辑。

  ```
  class MyLineParser extends BasicLineParser {
 
      @Override
      public Header parseHeader(
              CharArrayBuffer buffer) throws ParseException {
          try {
              return super.parseHeader(buffer);
          } catch (ParseException ex) {
              // Suppress ParseException exception
              return new BasicHeader(buffer.toString(), null);
          }
      }
 
  }
  ```

* 提供自定义的HttpConnectionFactory实现。 根据需要将默认请求编写器和/或响应解析器替换为自定义。

  ```
  HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory =
          new ManagedHttpClientConnectionFactory(
              new DefaultHttpRequestWriterFactory(),
              new DefaultHttpResponseParserFactory(
                      new MyLineParser(), new DefaultHttpResponseFactory()));
  ```

* 配置HttpClient以使用自定义连接工厂。

  ```
  PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(
      connFactory);
  CloseableHttpClient httpclient = HttpClients.custom()
          .setConnectionManager(cm)
          .build();
  ```

## 7.2. 有状态的HTTP连接

虽然HTTP规范假定会话状态信息始终以HTTP cookie的形式嵌入HTTP消息中，因此HTTP连接始终是无状态的，但这种假设在现实生活中并不总是如此。 有些情况下，使用特定用户标识或特定安全上下文创建HTTP连接，因此无法与其他用户共享，并且只能由同一用户重用。 此类有状态HTTP连接的示例是NTLM身份验证连接和具有客户端证书身份验证的SSL连接。

### 7.2.1. 用户令牌处理程序

HttpClient依赖于UserTokenHandler接口来确定给定的执行上下文是否是用户特定的。 如果上下文是特定于用户的，则此处理程序返回的标记对象应唯一标识当前用户，如果上下文不包含特定于当前用户的任何资源或详细信息，则该标记对象为null。 用户令牌将用于确保不会与其他用户共享或重用用户特定资源。

如果可以从给定的执行上下文获取，则UserTokenHandler接口的默认实现使用Principal类的实例来表示HTTP连接的状态对象。 DefaultUserTokenHandler将使用基于连接的身份验证方案（如NTLM）的用户主体或启用了客户端身份验证的SSL会话的用户主体。 如果两者都不可用，则返回空令牌。

```
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpClientContext context = HttpClientContext.create();
HttpGet httpget = new HttpGet("http://localhost:8080/");
CloseableHttpResponse response = httpclient.execute(httpget, context);
try {
    Principal principal = context.getUserToken(Principal.class);
    System.out.println(principal);
} finally {
    response.close();
}
```

如果默认实现不满足其需求，用户可以提供自定义实现：

```
UserTokenHandler userTokenHandler = new UserTokenHandler() {
 
    public Object getUserToken(HttpContext context) {
        return context.getAttribute("my-token");
    }
 
};
CloseableHttpClient httpclient = HttpClients.custom()
        .setUserTokenHandler(userTokenHandler)
        .build();
```

### 7.2.2. 持久的有状态连接

请注意，只有在执行请求时将相同的状态对象绑定到执行上下文时，才能重用带有状态对象的持久连接。 因此，确保相同的上下文被重用于同一用户执行后续HTTP请求或者在请求执行之前用户令牌绑定到上下文非常重要。

```
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpClientContext context1 = HttpClientContext.create();
HttpGet httpget1 = new HttpGet("http://localhost:8080/");
CloseableHttpResponse response1 = httpclient.execute(httpget1, context1);
try {
    HttpEntity entity1 = response1.getEntity();
} finally {
    response1.close();
}
Principal principal = context1.getUserToken(Principal.class);
 
HttpClientContext context2 = HttpClientContext.create();
context2.setUserToken(principal);
HttpGet httpget2 = new HttpGet("http://localhost:8080/");
CloseableHttpResponse response2 = httpclient.execute(httpget2, context2);
try {
    HttpEntity entity2 = response2.getEntity();
} finally {
    response2.close();
}
```

## 7.3. 使用FutureRequestExecutionService

使用FutureRequestExecutionService，您可以安排http调用并将响应视为Future。 这在例如 多次调用Web服务。 使用FutureRequestExecutionService的优点是，您可以使用多个线程同时调度请求，设置任务超时，或者在不再需要响应时取消它们。

FutureRequestExecutionService使用扩展FutureTask的HttpRequestFutureTask包装请求。 此类允许您取消任务以及跟踪各种指标，例如请求持续时间。

### 7.3.1. 创建FutureRequestExecutionService

futureRequestExecutionService的构造函数接受任何现有的httpClient实例和ExecutorService实例。 配置两者时，必须将最大连接数与要使用的线程数对齐。 当线程多于连接时，连接可能会开始超时，因为没有可用的连接。 当连接多于线程时，futureRequestExecutionService将不会使用所有连接

```
HttpClient httpClient = HttpClientBuilder.create().setMaxConnPerRoute(5).build();
ExecutorService executorService = Executors.newFixedThreadPool(5);
FutureRequestExecutionService futureRequestExecutionService =
    new FutureRequestExecutionService(httpClient, executorService);
```

### 7.3.2. 调度请求

要安排请求，只需提供HttpUriRequest，HttpContext和ResponseHandler。 由于请求由执行程序服务处理，因此必须使用ResponseHandler。

```
private final class OkidokiHandler implements ResponseHandler<Boolean> {
    public Boolean handleResponse(
            final HttpResponse response) throws ClientProtocolException, IOException {
        return response.getStatusLine().getStatusCode() == 200;
    }
}
 
HttpRequestFutureTask<Boolean> task = futureRequestExecutionService.execute(
    new HttpGet("http://www.google.com"), HttpClientContext.create(),
    new OkidokiHandler());
// blocks until the request complete and then returns true if you can connect to Google
boolean ok=task.get();
```

### 7.3.3. 取消任务

计划任务可能会被取消。 如果任务尚未执行但仅排队执行，则它将永远不会执行。 如果它正在执行并且mayInterruptIfRunning参数设置为true，则将在请求上调用abort（）; 否则响应将被忽略但请求将被允许正常完成。 对task.get（）的任何后续调用都将失败并返回IllegalStateException。 应该注意的是，取消任务只会释放客户端资源。 该请求实际上可以在服务器端正常处理。

```
task.cancel(true)
task.get() // throws an Exception
```

### 7.3.4. 回调

您也可以使用FutureCallback实例在请求完成时获取回调，而不是手动调用task.get（）。 这与HttpAsyncClient中使用的接口相同

```
private final class MyCallback implements FutureCallback<Boolean> {
 
    public void failed(final Exception ex) {
        // do something
    }
 
    public void completed(final Boolean result) {
        // do something
    }
 
    public void cancelled() {
        // do something
    }
}
 
HttpRequestFutureTask<Boolean> task = futureRequestExecutionService.execute(
    new HttpGet("http://www.google.com"), HttpClientContext.create(),
    new OkidokiHandler(), new MyCallback());
```

### 7.3.5. 度量

FutureRequestExecutionService通常用于进行大量Web服务调用的应用程序中。 为了便于例如 通过监视或配置调优，FutureRequestExecutionService可以跟踪多个指标。

每个HttpRequestFutureTask都提供了获取任务计划，启动和结束时间的方法。 此外，还可以使用请求和任务持续时间。 这些度量标准在FutureRequestExecutionMetrics实例中的FutureRequestExecutionService中聚合，可以通过FutureRequestExecutionService.metrics（）访问。

```
task.scheduledTime() // returns the timestamp the task was scheduled
task.startedTime() // returns the timestamp when the task was started
task.endedTime() // returns the timestamp when the task was done executing
task.requestDuration // returns the duration of the http request
task.taskDuration // returns the duration of the task from the moment it was scheduled
 
FutureRequestExecutionMetrics metrics = futureRequestExecutionService.metrics()
metrics.getActiveConnectionCount() // currently active connections
metrics.getScheduledConnectionCount(); // currently scheduled connections
metrics.getSuccessfulConnectionCount(); // total number of successful requests
metrics.getSuccessfulConnectionAverageDuration(); // average request duration
metrics.getFailedConnectionCount(); // total number of failed tasks
metrics.getFailedConnectionAverageDuration(); // average duration of failed tasks
metrics.getTaskCount(); // total number of tasks scheduled
metrics.getRequestCount(); // total number of requests
metrics.getRequestAverageDuration(); // average request duration
metrics.getTaskAverageDuration(); // average task duration
```
